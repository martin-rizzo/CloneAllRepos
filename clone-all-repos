#!/bin/bash
#  Bash script to clone all repositories owned by a user
#  https://github.com/martin-rizzo/CloneAllRepos
#  by Martin Rizzo

# CONSTANTS (can be modified by the arguments passed to the script)
AllowSpacesInDir=false   # true = allow spaces in directory names
AllowDotsInDir=false     # true = allow dots in directory names
MaxDirLength=64          # maximum directory length (0 = no limit)
OutputDir='.'
DryRun=
UserName=
UserDir=
Command='clone_all_repos'
ScriptName=${0##*/}
ScriptVersion=0.1
Red='\033[1;31m'
Green='\033[1;32m'
Defcol='\033[0m'
Help="
Usage: $ScriptName [OPTIONS] USERNAME [DIR]

Clone all repositories owned by a specific user.

Options:
        --ssh       Clone repos using ssh (SSH keys must be configured)
    -n, --dry-run   Do not actually run any commands; just print them.
    -l, --list      List the user repositories
        --debug     Print internal info about each repo

    -h, --help      Print this help
        --version   Print script version

"

# COMMANDS USED IN THIS SCRIPT
ExternCommands='test read grep sed curl git'

#=========================== MAIN SCRIPT COMMANDS ===========================#

show_help() { echo "$Help"; }

print_version() { echo "$ScriptName v$ScriptVersion"; }

fatal_error() {
    echo -e "${Red}ERROR:${Defcol}" "${1:-$Error}" >/dev/stderr ; exit ${2:1}
}

clone_all_repos() {
    [ -z "$UserName" ] && show_help && exit 0
    for_each_repo_owned_by "$UserName" clone_repo
}

ssh_clone_all_repos() {
    [ -z "$UserName" ] && fatal_error 'Missing USERNAME parameter'
    for_each_repo_owned_by "$UserName" ssh_clone_repo
}

enumerate_all_repos() {
    [ -z "$UserName" ] && fatal_error 'Missing USERNAME parameter'
    for_each_repo_owned_by "$UserName" enumerate_repo
}

debug_all_repos() {
    [ -z "$UserName" ] && fatal_error 'Missing USERNAME parameter'
    for_each_repo_owned_by "$UserName" debug_repo
}

#============================== FOR EACH REPO ===============================#
#    local html_url description clone_url ssh_url

## Functions to be used with 'for_each_repo_owned_by'
##
## @param index         Position of the repo within the list
## @param html_url      The URL of the repository's page on GitHub
## @param description   A text describing the repo
## @param directory     The local directory where the repo will be cloned
## @param clone_url     The web URL to clone the repo
## @param ssh_url       The code to clone the repo using SSH
##
clone_repo() {
    local index=$1 html_url=$2 description=$3 directory=$4 clone_url=$5 ssh_url=$6
    $DryRun git clone "$git_pull_url" "$directory"
}
ssh_clone_repo() {
    local index=$1 html_url=$2 description=$3 directory=$4 clone_url=$5 ssh_url=$6
    local ssh_url=$(sed "s/^.*:\/\//git@/;s/\//:/" <<<"$git_pull_url")
    $DryRun git clone "$ssh_url" "$directory"
}
enumerate_repo() {
    local index=$1 html_url=$2 description=$3 directory=$4 clone_url=$5 ssh_url=$6
    [ -z "$description" -o  "$desciption" = '""' ] && description=$html_url
    printf "%3d: " $index; echo "$description"
}
debug_repo() {
    local index=$1 html_url=$2 description=$3 directory=$4 clone_url=$5 ssh_url=$6
    echo "$description"
    echo "    WEBPAGE   $html_url"
    echo "    GIT URL   $clone_url"
    echo "    SSH URL   $ssh_url"
    echo "    DIRECTORY $directory"
    echo
}

## Iterate over all user's repos and execute a function on each one
##
## @param username      The username of the repo owner
## @param repofunction  The function to execute on each repo
##
for_each_repo_owned_by() {
    local username=$1 repofunction=$2
    local url="https://api.github.com/users/$username/repos"
    local properties

    IFS=$'\n' read -r -d '' -a properties < <( cat repos.txt \
        | awk '/\{/{++cnt}; /\}/{--cnt}; cnt==1 && (/html_url/||/description/||/clone_url/||/ssh_url/){print($0)}' \
        | sed 's/:/\n/;s/,$//;s/^[[:space:]]*//;s/[[space:]]*$//' \
        && printf '\0' )
    proc_repo_properties "$repofunction" "${properties[@]}"
}

#=================================== MISC ===================================#

## Execute a function on every repo reported by the provided properties
##
## Properties definition starts at the second argument. The second
## argument is a property name; the third is its value; the fourth
## is the next property name; the fifth is its value; and so on in
## that orden. Only 4 properties are taken into account: "html_url",
## "description", "clone_url" & "ssh_url".
##
## @param repofunction
##     The function to execute for each repo
##
## @param properties
##     A long list of arguments in the form of name/value pair;
##     each pair represent a property in the JSON returned by github.
##
proc_repo_properties() {
    local repofunction=$1
    local index=0
    local dirfilter allowedchars
    local html_url description clone_url ssh_url

    #-- generate directory filter --------
    allowedchars='A-Za-z0-9'
    if $AllowSpacesInDir ; then
       allowedchars="${allowedchars} "
    fi
    if $AllowDotsInDir ; then
        allowedchars="${allowedchars}\."
    fi
    dirfilter='s/^"//;s/"$//;'"s/[^${allowedchars}]/_/g"
    if [ "$MaxDirLength" -gt 0 ]; then
        dirfilter="$dirfilter;s/^\(.\{$MaxDirLength\}\).*\$/\1/"
    fi

    #-- process each property -----------
    shift
    while test $# -gt 0; do
        case "$1" in
            '"html_url"')
              shift
              html_url=$(sed 's/^"//;s/"$//' <<<"$1")
              ;;
            '"description"')
              shift
              description=$1
              directory=$(generate_dir "$dirfilter" "$description" "$html_url")
              ;;
            '"clone_url"')
              shift
              clone_url=$(sed 's/^"//;s/"$//' <<<"$1")
              ;;
            '"ssh_url"')
              shift
              ssh_url=$(sed 's/^"//;s/"$//' <<<"$1")
              ;;
        esac
        if [ ! -z "$html_url"    -a \
             ! -z "$description" -a \
             ! -z "$directory"   -a \
             ! -z "$clone_url"   -a \
             ! -z "$ssh_url"   ]
        then
            ((index++))
            "$repofunction" $index "$html_url" "$description" "$directory" "$clone_url" "$ssh_url"
            html_url=;description=;directory=;clone_url=;ssh_url=;
        fi
        shift
    done
}

generate_dir() {
    local dirfilter=$1 description=$2 html_url=$3

    local directory=$(sed "$dirfilter" <<<"$description")
    local alphachars=$(sed 's/^A-Za-z0-9//g' <<<"$directory")
    [ ${#alphachars} -lt 5 ] && directory=$(sed "s/^.*:\/\///;$dirfilter" <<<"$html_url")
    echo "${OutputDir}/$directory"
}

#================================== START ===================================#

while test $# -gt 0; do
    case "$1" in
        -n | --dry-run)
          DryRun=echo
          ;;
        --ssh)
          Command='ssh_clone_all_repos'
          ;;
        -l | --list)
          Command='enumerate_all_repos'
          ;;
        --debug)
          Command='debug_all_repos'
          ;;
        -h | --help)
          Command='show_help'
          ;;
        --version)
          Command='print_version'
          ;;
        -*)
          Command='fatal_error';Error="Unknown option '$1'"
          ;;
        *)
          if   [ -z "$UserName" ]; then UserName=$1
          elif [ -z "$UserDir"  ]; then UserDir=$1
          else Command='fatal_error';Error="Unsupported extra argument '$1'"
          fi
          ;;
    esac
    shift
done

# update output directory
OutputDir=${UserDir:-$OutputDir}
OutputDir=${OutputDir%/}

# verify output directory exist
[ ! -d "$OutputDir" ] && fatal_error "Directory '$OutputDir' does not exist"

# execute script command
"$Command"
